import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import requests
import threading
from PIL import Image, ImageTk
import io
import json
import os
import time

# --- 핵심 데이터 및 로직 ---
SPID_URL = "https://open.api.nexon.com/static/fconline/meta/spid.json"
SEASONID_URL = "https://open.api.nexon.com/static/fconline/meta/seasonid.json"

# (기존)
# SPID_FILENAME = "spid.json"
# SEASONID_FILENAME = "seasonid.json"

# --- (수정) AppData 폴더 경로 설정 ---
# 1. 'APPDATA' 환경 변수를 읽어옵니다. (예: C:\Users\YourName\AppData\Roaming)
# 2. 그 안에 우리 프로그램만의 폴더 이름을 정합니다. (예: FCOnlineSearcher)
APP_DATA_DIR = os.path.join(os.environ['APPDATA'], 'FCOnlineImageSearcher')
# 3. 파일 경로를 이 새 폴더로 지정합니다.
SPID_FILENAME = os.path.join(APP_DATA_DIR, "spid.json")
SEASONID_FILENAME = os.path.join(APP_DATA_DIR, "seasonid.json")

BASE_IMAGE_URL = "https://fco.dn.nexoncdn.co.kr/live/externalAssets/common/playersAction/p{spid}.png"
API_KEY = "private"

def load_json_file(filename):
    if os.path.exists(filename):
        with open(filename, 'r', encoding='utf-8') as f:
            try: return json.load(f)
            except json.JSONDecodeError: return {}
    return {}

class PlayerSearchApp:
    def __init__(self, root):
        self.root = root
        self.root.title("FC 온라인 선수 이미지 검색기") # 타이틀 한글화
        self.root.geometry("950x750") # 탐색 시즌 관리 탭이 없어지면서 창 높이를 약간 줄임
        
        # --- 창 크기 고정 ---
        # 적응형 창 크기 버그가 있어 잠시 설정
        self.root.resizable(False, False)
        
        # --- (수정) AppData 폴더가 없으면 생성 ---
        # 이 코드는 APP_DATA_DIR (예: ...\FCOnlineImageSearcher) 폴더가
        # 존재하는지 확인하고, 없으면 자동으로 생성합니다.
        os.makedirs(APP_DATA_DIR, exist_ok=True)
        # --- (수정 끝) ---

        self.style = ttk.Style()
        self.style.theme_use('clam')

        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        self.notebook = ttk.Notebook(main_frame)
        
        # --- 1번 탭: 선수 이름/ID 검색 (한글화) ---
        player_tab = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(player_tab, text="선수 이름 또는 ID로 검색")
        
        search_line_frame = ttk.Frame(player_tab)
        search_line_frame.pack(fill=tk.X)
        
        ttk.Label(search_line_frame, text="선수 이름/ID:").pack(side=tk.LEFT, padx=5)
        self.player_search_combobox = ttk.Combobox(search_line_frame, width=20)
        self.player_search_combobox.pack(side=tk.LEFT, padx=5)
        self.player_search_combobox.bind('<KeyRelease>', self.update_autocomplete)
        
        self.search_player_button = ttk.Button(search_line_frame, text="모든 시즌 검색", command=self.start_smart_player_search_thread)
        self.search_player_button.pack(side=tk.LEFT, padx=5)
        
        instruction_label = ttk.Label(
            player_tab, 
            text="키보드 아래 화살표(↓) 키를 누르면 추천 목록을 볼 수 있습니다.",
            font=("Arial", 8),
            foreground="gray"
        )
        instruction_label.pack(anchor='w', padx=5, pady=(2,0))

        # --- 2번 탭: 시즌 코드로 검색 (한글화) ---
        season_tab = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(season_tab, text="시즌 코드로 검색")
        ttk.Label(season_tab, text="시즌 코드 (3자리):").pack(side=tk.LEFT, padx=5)
        self.season_code_entry = ttk.Entry(season_tab, width=10)
        self.season_code_entry.pack(side=tk.LEFT, padx=5)
        self.search_season_button = ttk.Button(season_tab, text="시즌 검색", command=self.start_season_search_thread)
        self.search_season_button.pack(side=tk.LEFT, padx=5)

        # --- 검색 결과 프레임 및 하단 바 (한글화) ---
        results_frame = ttk.LabelFrame(main_frame, text="검색 결과 (이미지 우클릭 시 저장)", padding="10")
        
        self.canvas = tk.Canvas(results_frame)
        self.scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.canvas.yview)
        
        # --- (수정 1) 가로 스크롤바 추가 ---
        self.h_scrollbar = ttk.Scrollbar(results_frame, orient="horizontal", command=self.canvas.xview)
        
        self.image_grid_frame = ttk.Frame(self.canvas)
        self.image_grid_frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        
        # 캔버스 내부에 프레임 추가 (ID는 더 이상 필요 없지만 저장은 해둠)
        self.image_grid_frame_id = self.canvas.create_window((0, 0), window=self.image_grid_frame, anchor="nw")
        
        # --- (수정 2) 캔버스에 가로/세로 스크롤바 모두 연결 ---
        self.canvas.configure(yscrollcommand=self.scrollbar.set, xscrollcommand=self.h_scrollbar.set)
        
        self.canvas.bind("<Configure>", self.on_resize)
        
        # --- (수정 3) 스크롤바 packing 순서 변경 ---
        # 스크롤바를 먼저 pack하고 캔버스가 남은 공간을 채우도록 함
        self.scrollbar.pack(side=tk.RIGHT, fill="y")
        self.h_scrollbar.pack(side=tk.BOTTOM, fill="x") # 가로 스크롤바를 아래쪽에 배치
        self.canvas.pack(side=tk.LEFT, fill="both", expand=True) # 캔버스가 남은 공간을 채움
        
        bottom_frame = ttk.Frame(main_frame)
        bottom_frame.pack(fill=tk.X, padx=5, pady=(5,0))
        
        self.status_label = ttk.Label(bottom_frame, text="준비 완료.") # 초기 상태 메시지 한글화
        self.status_label.pack(side=tk.LEFT)
        
        self.stop_button = ttk.Button(bottom_frame, text="검색 중지", command=self.stop_search, state=tk.DISABLED) # 버튼 텍스트 한글화
        self.stop_button.pack(side=tk.RIGHT)

        self.notebook.pack(side=tk.TOP, fill=tk.X, padx=5, pady=5)
        results_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True, padx=5, pady=(0,5))
        
        # --- 데이터 및 상태 변수 ---
        self.image_references, self.search_results, self.all_players_list = [], [], []
        self.current_search_thread, self._debounce_timer = None, None
        self.season_id_map, self.name_to_pid_map, self.pid_to_name_map, self.all_player_names = {}, {}, {}, []
        self.stop_event = threading.Event()

        self.load_metadata_thread()

    # --- 유틸리티 함수들 (한글화된 메시지) ---
    def update_status(self, message):
        self.status_label.config(text=message)
        self.root.update_idletasks()

    def on_resize(self, event):
        # --- (수정) event.width 값을 직접 사용하도록 변경 ---
        
        # event.width가 비정상적으로 작은 값(예: 1)일 때는 무시
        if event.width < 150:
            return

        if self._debounce_timer: self.root.after_cancel(self._debounce_timer)
        
        # lambda를 사용해 'event.width' 값을 150ms 후의 함수에 전달
        new_width = event.width
        self._debounce_timer = self.root.after(150, lambda: self.redraw_image_grid(canvas_width=new_width))
        

    def save_image_as(self, item):
        if not item or "image_data" not in item: return
        default_name = f"p{item['spid']}.png"
        filepath = filedialog.asksaveasfilename(initialfile=default_name, defaultextension=".png", filetypes=[("PNG 파일", "*.png"), ("모든 파일", "*.*")]) # 파일 타입 한글화
        if filepath:
            try:
                with open(filepath, 'wb') as f: f.write(item['image_data'])
                self.update_status(f"이미지를 '{os.path.basename(filepath)}'에 저장했습니다.") # 메시지 한글화
            except Exception as e:
                messagebox.showerror("저장 실패", f"이미지를 저장하는 데 실패했습니다.\n{e}") # 메시지 한글화
                self.update_status("오류: 이미지 저장 실패") # 메시지 한글화
    
    def clear_results(self):
        self.search_results.clear()
        self.redraw_image_grid()

    def add_result_data(self, image_data, spid, name):
        self.search_results.append({"image_data": image_data, "spid": str(spid), "name": name})
        self.root.after(10, self.redraw_image_grid)

    def set_buttons_state(self, state):
        search_buttons_state = state
        stop_button_state = tk.NORMAL if state == tk.DISABLED else tk.DISABLED
        self.search_player_button.config(state=search_buttons_state)
        self.search_season_button.config(state=search_buttons_state)
        self.stop_button.config(state=stop_button_state)

    def stop_search(self):
        if self.current_search_thread and self.current_search_thread.is_alive():
            self.stop_event.set()
            self.update_status("검색을 중지하는 중...") # 메시지 한글화
            
    def update_autocomplete(self, event):
        typed_text = self.player_search_combobox.get().lower()
        if event.keysym in ("Up", "Down", "Left", "Right", "Shift_L", "Shift_R", "Control_L", "Control_R", "Return", "Escape"): return
        if not typed_text: self.player_search_combobox['values'] = []; return
        matching_names = [name for name in self.all_player_names if typed_text in name.lower()]
        self.player_search_combobox['values'] = matching_names[:100]

    def redraw_image_grid(self, canvas_width=None): # --- (수정) 매개변수 추가 ---
        for widget in self.image_grid_frame.winfo_children(): widget.destroy()
        self.image_references.clear()
        
        # --- (수정) canvas_width가 인수로 전달되지 않으면(None이면)
        # (예: add_result_data에서 호출된 경우) 기존 방식대로 위젯 너비를 가져옴
        if canvas_width is None:
            canvas_width = self.canvas.winfo_width() 
        # --- (수정 끝) ---
        
        if canvas_width < 150: 
            canvas_width = 150 
            
        item_width_estimate = 150 
        num_columns = max(1, canvas_width // item_width_estimate)
        
        for index, item in enumerate(self.search_results):
            row, col = index // num_columns, index % num_columns
            try:
                raw_image = Image.open(io.BytesIO(item["image_data"]))
                resized_image = raw_image.resize((128, 128), Image.Resampling.LANCZOS)
                photo = ImageTk.PhotoImage(resized_image)
                self.image_references.append(photo)
                cell_frame = ttk.Frame(self.image_grid_frame, padding=5)
                cell_frame.grid(row=row, column=col, padx=5, pady=5)
                image_label = ttk.Label(cell_frame, image=photo, cursor="hand2")
                image_label.pack()
                spid_int = int(item['spid'])
                season_id = str(spid_int // 1000000)
                if season_id in self.season_id_map: season_name = self.season_id_map.get(season_id)
                else: season_name = f"시즌코드: {season_id}"
                season_label = ttk.Label(cell_frame, text=season_name, font=("Arial", 10, "bold"), justify=tk.CENTER, cursor="hand2")
                season_label.pack()
                player_name_label = ttk.Label(cell_frame, text=item["name"], font=("Arial", 9), justify=tk.CENTER, cursor="hand2")
                player_name_label.pack()
                spid_label = ttk.Label(cell_frame, text=f"p{item['spid']}", font=("Arial", 9), justify=tk.CENTER, cursor="hand2")
                spid_label.pack()
                cell_frame.bind("<Button-3>", lambda e, current_item=item: self.save_image_as(current_item))
                image_label.bind("<Button-3>", lambda e, current_item=item: self.save_image_as(current_item))
                season_label.bind("<Button-3>", lambda e, current_item=item: self.save_image_as(current_item))
                player_name_label.bind("<Button-3>", lambda e, current_item=item: self.save_image_as(current_item))
                spid_label.bind("<Button-3>", lambda e, current_item=item: self.save_image_as(current_item))
            except Exception as e: print(f"이미지 표시 오류: {e}") # 메시지 한글화

    def load_metadata_thread(self):
        self.set_buttons_state(tk.DISABLED)
        self.update_status("메타데이터 확인 중...") # 메시지 한글화
        self.current_search_thread = threading.Thread(target=self.get_metadata_files)
        self.current_search_thread.daemon = True
        self.current_search_thread.start()

    def get_metadata_files(self):
        headers = {"Authorization": API_KEY}
        try:
            for filename, url in [(SPID_FILENAME, SPID_URL), (SEASONID_FILENAME, SEASONID_URL)]:
                needs_download = False
                if not os.path.exists(filename): needs_download = True
                else:
                    try:
                        response = requests.head(url, headers=headers, timeout=5)
                        response.raise_for_status()
                        server_size = int(response.headers.get('Content-Length', 0))
                        local_size = os.path.getsize(filename)
                        if server_size != 0 and local_size != server_size: needs_download = True
                    except requests.RequestException: needs_download = False
                if needs_download:
                    self.root.after(0, self.update_status, f"'{filename}' 다운로드 중...") # 메시지 한글화
                    response = requests.get(url, headers=headers)
                    response.raise_for_status()
                    with open(filename, "w", encoding="utf-8") as f: f.write(response.text)
            self.root.after(0, self.update_status, "메타데이터 파일 로딩 중...") # 메시지 한글화
            with open(SPID_FILENAME, 'r', encoding='utf-8') as f: self.all_players_list = json.load(f)
            with open(SEASONID_FILENAME, 'r', encoding='utf-8') as f: season_data = json.load(f)
            self.season_id_map = {str(item['seasonId']): item['className'] for item in season_data}
            self.name_to_pid_map = {p['name']: str(p['id'])[-6:].zfill(6) for p in self.all_players_list}
            self.pid_to_name_map = {str(p['id'])[-6:].zfill(6): p['name'] for p in self.all_players_list}
            self.all_player_names = sorted(list(self.name_to_pid_map.keys()))
            self.player_search_combobox['values'] = []
        except Exception as e:
            self.root.after(0, messagebox.showerror, "메타데이터 오류", f"메타데이터 로딩/다운로드에 실패했습니다.\n네트워크 연결을 확인하세요.\n{e}") # 메시지 한글화
            self.root.after(0, self.update_status, "오류: 메타데이터 로딩 실패") # 메시지 한글화
            return
        self.root.after(0, self.update_status, f"준비 완료. 총 {len(self.all_player_names)}명의 고유 선수 정보 로드됨.") # 메시지 한글화
        self.root.after(0, lambda: self.set_buttons_state(tk.NORMAL))
    
    def start_smart_player_search_thread(self):
        self.stop_event.clear()
        query = self.player_search_combobox.get().strip()
        if not query: self.update_status("오류: 선수 이름 또는 ID를 입력하세요."); return # 메시지 한글화
        player_id, player_name = None, None
        if query.isdigit() and len(query) <= 6:
            player_id = query.zfill(6); player_name = self.pid_to_name_map.get(player_id, "알 수 없는 선수") # 메시지 한글화
        else:
            player_name = query; player_id = self.name_to_pid_map.get(player_name)
        if player_id is None: self.update_status(f"오류: '{query}'에 해당하는 선수를 찾을 수 없습니다."); return # 메시지 한글화
        self.clear_results()
        self.update_status(f"선수 [{player_name}]의 모든 시즌 검색 시작...") # 메시지 한글화
        self.set_buttons_state(tk.DISABLED)
        self.current_search_thread = threading.Thread(target=self.search_all_seasons_for_player, args=(player_id, player_name))
        self.current_search_thread.daemon = True
        self.current_search_thread.start()

    def search_all_seasons_for_player(self, player_id, player_name):
        found_count = 0
        try:
            # --- (수정) range 범위를 0~999 에서 100~999 로 변경 ---
            for i in range(100, 1000):
                if self.stop_event.is_set(): break
                season_code_str = f"{i:03d}"
                spid = int(season_code_str + player_id)
                
                # (i % 20) == 0 조건은 100부터 시작하므로 첫 번째에도 바로 실행됩니다.
                # (i-100) % 20 == 0 처럼 바꿔서 100일때가 아닌 20번째에 실행되게 하거나
                # (i % 20 == 0)를 그대로 두어 100, 120, 140... 마다 상태를 업데이트하게 할 수 있습니다.
                if i % 20 == 0: self.root.after(0, self.update_status, f"시즌 [{season_code_str}] 확인 중...") # 메시지 한글화
                
                url = BASE_IMAGE_URL.format(spid=spid)
                try:
                    response = requests.head(url, timeout=1.0)
                    if response.status_code == 200:
                        img_response = requests.get(url, timeout=3)
                        if img_response.status_code == 200:
                            found_count += 1
                            self.root.after(0, self.add_result_data, img_response.content, spid, player_name)
                except requests.RequestException: continue
        finally:
            final_message = f"검색 완료! [{player_name}] 선수의 총 {found_count}개 시즌을 찾았습니다." # 메시지 한글화
            if self.stop_event.is_set(): final_message = "검색을 중지했습니다." # 메시지 한글화
            self.root.after(0, self.update_status, final_message)
            self.root.after(0, lambda: self.set_buttons_state(tk.NORMAL))

    def start_season_search_thread(self):
        self.stop_event.clear()
        season_code = self.season_code_entry.get().strip()
        if not (season_code.isdigit() and len(season_code) == 3): self.update_status("오류: 3자리 숫자 형식의 시즌 코드를 입력하세요. (예: 101)"); return # 메시지 한글화
        self.clear_results()
        search_mode = ""
        if season_code in self.season_id_map: search_mode = "STANDARD"; self.update_status(f"시즌 [{season_code}] 선수 필터링 시작...") # 메시지 한글화
        else: search_mode = "NEW_DISCOVERY"; self.update_status(f"미확인 시즌 [{season_code}] 탐색 시작... (매우 느림)") # 메시지 한글화
        self.set_buttons_state(tk.DISABLED)
        self.current_search_thread = threading.Thread(target=self.search_players_in_season, args=(season_code, search_mode))
        self.current_search_thread.daemon = True
        self.current_search_thread.start()

    def search_players_in_season(self, season_code, mode):
        try:
            if mode == "STANDARD":
                season_code_int = int(season_code)
                target_players = [p for p in self.all_players_list if (p['id'] // 1000000) == season_code_int]
                if not target_players: self.root.after(0, self.update_status, f"시즌 [{season_code}]에 해당하는 선수가 없습니다."); return # 메시지 한글화
                self.root.after(0, self.update_status, f"총 {len(target_players)}명의 선수 이미지 다운로드 중...") # 메시지 한글화
                for i, player in enumerate(target_players):
                    if self.stop_event.is_set(): break
                    spid, name = player['id'], player['name']
                    if (i + 1) % 5 == 0 or i == len(target_players) - 1: self.root.after(0, self.update_status, f"다운로드 중... ({i+1}/{len(target_players)}, {(i + 1) / len(target_players) * 100:.1f}%)") # 메시지 한글화
                    url = BASE_IMAGE_URL.format(spid=spid)
                    try:
                        response = requests.get(url, timeout=3)
                        if response.status_code == 200: self.root.after(0, self.add_result_data, response.content, spid, name)
                    except requests.RequestException: continue
            elif mode == "NEW_DISCOVERY":
                newly_found_players = []
                pid_list = list(self.pid_to_name_map.keys())
                total_pids = len(pid_list)
                for i, pid in enumerate(pid_list):
                    if self.stop_event.is_set(): break
                    new_spid = int(season_code + pid)
                    player_name = self.pid_to_name_map[pid]
                    if (i + 1) % 100 == 0: self.root.after(0, self.update_status, f"탐색 중... ({i+1}/{total_pids}, {(i + 1) / total_pids * 100:.1f}%)") # 메시지 한글화
                    url = BASE_IMAGE_URL.format(spid=new_spid)
                    try:
                        response = requests.head(url, timeout=1.5)
                        if response.status_code == 200:
                            img_response = requests.get(url, timeout=3)
                            if img_response.status_code == 200:
                                newly_found_players.append({'id': new_spid, 'name': player_name})
                                self.root.after(0, self.add_result_data, img_response.content, new_spid, player_name)
                    except requests.RequestException: continue
        finally:
            final_message = f"검색 완료! 총 {len(self.search_results)}개의 이미지를 찾았습니다." # 메시지 한글화
            if self.stop_event.is_set(): final_message = "검색을 중지했습니다." # 메시지 한글화
            self.root.after(0, self.update_status, final_message)
            self.root.after(0, lambda: self.set_buttons_state(tk.NORMAL))

if __name__ == "__main__":
    root = tk.Tk()
    app = PlayerSearchApp(root)
    root.mainloop()
